# Debugging, testing, and correlation {#sec-debugging-and-testing}

```{r}
#| echo: FALSE
# We want errors to show up in this notebook
options(error = recover)
# this code is only for getting the data into the notebook during publishing
data(corre_categorical, package = "planteda")
data(corre_continuous, package = "planteda")
```

:::{.callout-caution}
### WORK IN PROGRESS
This chapter is not yet finished, come back later for the final product
:::

Programming and scripting for data analysis is _not only_ about writing code that runs.
It is perhaps even more important to write code that produces correct and interpretable results.

Errors in code can become especially dangerous when they silently produce wrong results without throwing errors.
In this chapter we will go over different types of errors and warnings and how you can solve and prevent them.

:::{#wrn-analysis-gone-wrong .callout-warning appearance='simple'}
## Data analysis code gone wrong, famous examples
In the late 2000s, researchers claimed that gene-expression data from cancer cell lines could be used to predict which chemotherapy drugs would work for individual patients. 
These results were considered so promising that human clinical trials were started based on the predictions.
Later, independent scientists tried to reproduce the analysis and found that the problem was not the biological question or the statistical methodology, but simple bugs in the data-analysis code [@Baggerly2009].
Gene-expression tables had been misaligned with patient labels, some samples had been accidentally swapped, and categorical variables had been silently reordered by the software.
Because the analysis pipeline contained no checks that data and labels still matched, these errors went unnoticed.
The models therefore looked highly accurate, while in reality they were making predictions close to random guessing.
When the mistakes were corrected, the supposed drug-response signatures disappeared.
Several papers were withdrawn and the clinical trials were stopped.
This episode is now a classic warning that small programming errors can lead to large scientific and real-world consequences.
The take home message: careful debugging and reproducible workflows matter in data-driven biology.
:::


We will work on two complementary skill sets:

- Debugging and error handling:
- Testing and validating: 

## Debugging and error handling

[Bugs](https://en.wikipedia.org/wiki/Software_bug) and errors go hand in hand: 

### Syntax errors
These errors often pop up when you are in the process of writing some new code. 
Simply put, a syntax error is any form of mistake where your code does not follow the [syntax](https://en.wikipedia.org/wiki/Syntax) definitions of the R language.
As a consequence, the code cannot be parsed and executed by the interpreter. 
These error are caught relatively easy, because any syntax error will break the execution of your code.
In addition, when viewing the full error message (see note [...]), a syntax error always starts with `Error in parse(text = input): [...]` indicating that _parsing_ of the code failed.

```{r}
#| error: TRUE
# Syntax error example 1, missing closing bracket
collection <- c(1,2,3,
```

Note that in R, code is interpreted and potentially executed on a line-by-line basis. 
Executing syntax error example 2 (below) in a clean environment will crash on the second line, but the first line will already have executed when the crash happens.
As a result, in this example the variable `collection` _will_ exist when the crash happens.


```{r}
#| error: TRUE
# Syntax error example 2, the last line is missing the closing bracket
collection <- c(1,2,3)
collection[1
```
An exception to the line-by-line interpretation and execution is how code blocks are treated. Examples 3 and 4 show examples of syntax errors in code blocks: function definitions and loops are first completely interpreted before they are executed.

```{r}
#| error: TRUE
# Syntax error example 3, using incorrect bracket types
my_function <- function(arg){
  return(arg + 1)
]

```

```{r}
#| error: TRUE
# Syntax error example 4, a syntax error in a loop
for (i in 1:3){
  print(i)
  print('There is a syntax error on this line)
}
```
### Runtime errors {#sec-runtime-errors}
A class of errors that will also break execution of your code are the runtime errors. 
Unlike syntax errors, the code can be parsed and interpreted, but there is an underlying problem when trying to execute the code that causes the interpreter to crash.

```{r}
#| error: TRUE
# Runtime error example 1: mismatched types
1 + "2"
```

```{r}
#| error: TRUE
# Runtime error example 2: trailing commas/empty arguments are valid syntax but can break at runtime
collection <- c(1,2,3,)
```

Runtime errors are defined in code and make your code crash when some checks are failing. 
It is relatively straightforward to implement a check and produce an error (see runtime example 3 below).
We will use this more strategically in @sec-testing-and-validating.

```{r}
#| error: TRUE
# Runtime error example 3: implementing a custom check and producing a runtime error
my_function <- function(arg){
  if (arg > 3) {
    stop("arg must be <= 3, got ", arg)
  }
  print(arg)
}
my_function(2)
my_function(4)
```

### Warnings {#sec-warnings}
In some cases, functions that you use might warn you when you are asking for unexpected behavior. One example we previously encountered are the warning messages of functions being overwritten when loading the `tidyverse` package. Warnings do not terminate your code, so just like logical errors you still get results. Unlike logical errors, you get some indication that there might be something not going as intended. Sometimes warnings can be safely ignored, sometimes they mean something is critically wrong.

```{r}
# Warning example 1: converting strings to number raises a warning, but you still get a result
as.numeric(corre_continuous$species[1:5])
```

:::{#exr-warning}
In the example above (when attempting to convert a character to a number), do you think it is appropriate to raise a warning, or would an error be a better choice? 
:::

Implementing warnings in your own functions can be a very powerful tool to keep track of what is happening in your analysis (see example below).
```{r}
# Warning example 2: raising a warning in a function

f <- function(arg){
  if (arg < 3) warning('arg must be >= 3, got ', arg)
  arg ** 2
}

f(2)
```
It is important to realize that warnings, just like runtime errors (@sec-runtime-errors), are implemented in R code by e.g. package maintainers. This means that whether or not a function raises a warning when something unexpected happens always depends on the function, and whether the function author implemented a check or not.

### Logical errors

In sections @seq-runtime-errors and @sec-warnings we have covered what happens when e.g. a package maintainer implements a check in their code. But what about errors in your code that do not cause an error or raise a warning?
These errors are potentially the most dangerous, because they do not show any direct visual clues that something is wrong. Any behavior of your code that does not result in the desired/expected result can be seen as a __logical error__. This can range from explicit mistakes in an implementation (e.g. messing up a mathematical calculation), to not realizing some hidden behavior of a certain function, to simple typo's in variable names. The example at the start of the chapter (@wrn-analysis-gone-wrong) is an example of logical errors: the code ran to completion and produced results, but due to some mistakes in the implementation the results were incorrect.

The crucial problem here is that there is nothing in the code that checks assumptions or e.g. enforces certain properties of datasets/results. In @sec-testing-and-validating we explore in more detail how you can implement some of these checks yourself.

:::{#exr-errors}
### Identify the error
For each of the following 10 exercises, identify the type of error, and fix the code so that it works as expected.

```{r}
#| eval: FALSE
# Exercise 1: Calculating average leaf Nitrogen content
mean(corre_continuous$leaf_N
     
# Exercise 2: Finding the most common growth form
mean(corre_categorical$growth_form)

# Exercise 3: Is there a relationship between plant family and leaf N content?
cor.test(corre_continuous$family, corre_continuous$leaf_N)

# Excercise 4: What is the average leaf dry mass?
mean(corre_continuous$leaf_dry_mass, na.rm = TRUE)

# Exercise 5: Select all the entries for the grass family
subset(corre_continuous, family = 'Poaceae')

# Exercise 6: Calculate mean leaf are
mean(corre_continuous$SLA)

# Exercise 7: Select the leaf area for the 1,000th plant
corre_continuous$leaf_area[10000]

# Exercise 8: Compute the average seed dry mass for grasses
subset(corre_continuous, family == 'Poaceae')$seed_dry_mass |> mean(na.rm = TRUE)

# Exercise 9: Compute the mean SLA for a specific family
mean_trait_by_family <- function(dataset, trait){
  mean(dataset[[trait]], na.rm = TRUE)
}
mean_trait_by_family(corre_continuous, 'SLA')

# Exercise 10: log-transform seed dry mass
log(corre_continuous$seed_dry_mass)
```

:::

## Testing and validating {#sec-testing-and-validating}