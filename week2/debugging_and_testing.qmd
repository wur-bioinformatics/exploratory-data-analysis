# Debugging, testing, and correlation {#sec-debugging-and-testing}

```{r}
#| echo: FALSE
# We want errors to show up in this notebook
options(error = recover)
# this code is only for getting the data into the notebook during publishing
data(corre_categorical, package = "planteda")
data(corre_continuous, package = "planteda")
data(grassland_traits_environment, package = "planteda")
```

:::{.callout-caution}
### WORK IN PROGRESS
This chapter is not yet finished, come back later for the final product
:::

Programming and scripting for data analysis is _not only_ about writing code that runs.
It is perhaps even more important to write code that produces correct and interpretable results.

Errors in code can become especially dangerous when they silently produce wrong results without throwing errors.
In this chapter we will go over different types of errors and warnings and how you can solve and prevent them.

We also cover a fundamental approach for comparing two variables: correlation. Calculating correlation is often an important part in the data analysis pipeline (@tip-data-science-cycle). Just like summary statistics, correlation can be relevant in both the inspecting and analyzing parts of the pipeline. Since correlation is about _comparing_ things, it is critical for the interpretation of a correlation analysis that it is clear what is being compared. We'll use some of the debugging and testing approaches from this chapter to make sure we calculate meaningful correlations and draw valid conclusions.

:::{#wrn-analysis-gone-wrong .callout-warning appearance='simple'}
## Data analysis code gone wrong, famous examples
In the late 2000s, researchers claimed that gene-expression data from cancer cell lines could be used to predict which chemotherapy drugs would work for individual patients. 
These results were considered so promising that human clinical trials were started based on the predictions.
Later, independent scientists tried to reproduce the analysis and found that the problem was not the biological question or the statistical methodology, but simple bugs in the data-analysis code [@Baggerly2009].
Gene-expression tables had been misaligned with patient labels, some samples had been accidentally swapped, and categorical variables had been silently reordered by the software.
Because the analysis pipeline contained no checks that data and labels still matched, these errors went unnoticed.
The models therefore looked highly accurate, while in reality they were making predictions close to random guessing.
When the mistakes were corrected, the supposed drug-response signatures disappeared.
Several papers were withdrawn and the clinical trials were stopped.
This episode is now a classic warning that small programming errors can lead to large scientific and real-world consequences.
The take home message: careful debugging and reproducible workflows matter in data-driven biology.
:::


We will work on two complementary skill sets:

- Debugging and error handling:
- Testing and validating: 

## Debugging and error handling

[Bugs](https://en.wikipedia.org/wiki/Software_bug) and errors go hand in hand: a __bug__ is an error or flaw in a program that causes it to behave differently from what the programmer intended. Bugs can cause code to crash with an error, produce warnings, or even run without complaint while giving incorrect results.

Bugs arise for many reasons: misunderstandings about how a function works, incorrect assumptions about the data, edge cases that were not considered, or simple typing mistakes. Importantly, a program can be syntactically correct (it runs) and still contain bugs if the logic is wrong.

__Debugging__ is the process of identifying, understanding, and fixing these bugs. Rather than trial-and-error, effective debugging relies on systematically inspecting code, checking assumptions, and narrowing down where the programâ€™s behavior diverges from expectations.

:::{.callout-note appearance='simple'}
### About the term "bug"
The word "bug" to describe a programming error is often linked to [Grace Hopper](https://en.wikipedia.org/wiki/Grace_Hopper). In 1947, while working on the Harvard Mark II computer, her team found that a malfunction was caused by a real moth trapped in a relay (back then computers where large devices that filled entire rooms). The insect was taped into the logbook with the note "First actual case of bug being found".

Although the term bug was already used informally in engineering, this incident popularized it in computing. It nicely illustrates an important idea: bugs can arise from unexpected causes, and finding them requires careful investigation rather than guesswork.
:::

:::{.callout-tip appearance='simple'}
### How to debug
The main approach to debugging (potentially complex) code is to be systematic. The following steps help in identifying the underlying problem:

1. __Reproduce the issue__: make sure you consistently see the bug. Does it only occur on a specific dataset? Or under other specific conditions? These can provide hints.
2. __Isolate the problem__: (especially when working with larger functions or big datasets) Narrow down where the error _actually_ comes from. Adding print statements or commenting out specific sections can help. Switching to a small test dataset can be useful too.
3. __Understand/hypothesize__: once you figured out where the error occurs, check what you expected to happen and verify this is (or is not) happening.
4. __Fix and verify__: Implement the fix, then _test_ the code by reproducing the original conditions under which the error occurred.
:::

To better understand what can cause your code to misbehave, it is useful to understand a little bit about different types of errors in R. The following section covers syntax errors, runtime errors, warnings, and logical errors.

### Syntax errors
These errors often pop up when you are in the process of writing some new code. 
Simply put, a syntax error is any form of mistake where your code does not follow the [syntax](https://en.wikipedia.org/wiki/Syntax) definitions of the R language.
As a consequence, the code cannot be parsed and executed by the interpreter. 
These error are caught relatively easy, because any syntax error will break the execution of your code.
In addition, when viewing the full error message (see note [...]), a syntax error always starts with `Error in parse(text = input): [...]` indicating that _parsing_ of the code failed.

```{r}
#| error: TRUE
# Syntax error example 1, missing closing bracket
collection <- c(1,2,3,
```

Note that in R, code is interpreted and potentially executed on a line-by-line basis. 
Executing syntax error example 2 (below) in a clean environment will crash on the second line, but the first line will already have executed when the crash happens.
As a result, in this example the variable `collection` _will_ exist when the crash happens.


```{r}
#| error: TRUE
# Syntax error example 2, the last line is missing the closing bracket
collection <- c(1,2,3)
collection[1
```
An exception to the line-by-line interpretation and execution is how code blocks are treated. Examples 3 and 4 show examples of syntax errors in code blocks: function definitions and loops are first completely interpreted before they are executed.

```{r}
#| error: TRUE
# Syntax error example 3, using incorrect bracket types
my_function <- function(arg){
  return(arg + 1)
]

```

```{r}
#| error: TRUE
# Syntax error example 4, a syntax error in a loop
for (i in 1:3){
  print(i)
  print('There is a syntax error on this line)
}
```
### Runtime errors {#sec-runtime-errors}
A class of errors that will also break execution of your code are the runtime errors. 
Unlike syntax errors, the code can be parsed and interpreted, but there is an underlying problem when trying to execute the code that causes the interpreter to crash.

```{r}
#| error: TRUE
# Runtime error example 1: mismatched types
1 + "2"
```

```{r}
#| error: TRUE
# Runtime error example 2: trailing commas/empty arguments are valid syntax but can break at runtime
collection <- c(1,2,3,)
```

Runtime errors are defined in code and make your code crash when some checks are failing. 
It is relatively straightforward to implement a check and produce an error (see runtime example 3 below).
We will use this more strategically in @sec-testing-and-validating.

```{r}
#| error: TRUE
# Runtime error example 3: implementing a custom check and producing a runtime error
my_function <- function(arg){
  if (arg > 3) {
    stop("arg must be <= 3, got ", arg)
  }
  print(arg)
}
my_function(2)
my_function(4)
```

### Warnings {#sec-warnings}
In some cases, functions that you use might warn you when you are asking for unexpected behavior. One example we previously encountered are the warning messages of functions being overwritten when loading the `tidyverse` package. Warnings do not terminate your code, so just like logical errors you still get results. Unlike logical errors, you get some indication that there might be something not going as intended. Sometimes warnings can be safely ignored, sometimes they mean something is critically wrong.

```{r}
# Warning example 1: converting strings to number raises a warning, but you still get a result
as.numeric(corre_continuous$species[1:5])
```

:::{#exr-warning}
In the example above (when attempting to convert a character to a number), do you think it is appropriate to raise a warning, or would an error be a better choice? 
:::

Implementing warnings in your own functions can be a very powerful tool to keep track of what is happening in your analysis (see example below).
```{r}
# Warning example 2: raising a warning in a function

f <- function(arg){
  if (arg < 3) warning('arg must be >= 3, got ', arg)
  arg ** 2
}

f(2)
```
It is important to realize that warnings, just like runtime errors (@sec-runtime-errors), are implemented in R code by e.g. package maintainers. This means that whether or not a function raises a warning when something unexpected happens always depends on the function, and whether the function author implemented a check or not.

### Logical errors

In sections @sec-runtime-errors and @sec-warnings we have covered what happens when e.g. a package maintainer implements a check in their code. But what about errors in your code that do not cause an error or raise a warning?
These errors are potentially the most dangerous, because they do not show any direct visual clues that something is wrong. Any behavior of your code that does not result in the desired/expected result can be seen as a __logical error__. This can range from explicit mistakes in an implementation (e.g. messing up a mathematical calculation), to not realizing some hidden behavior of a certain function, to simple typo's in variable names. The example at the start of the chapter (@wrn-analysis-gone-wrong) is an example of logical errors: the code ran to completion and produced results, but due to some mistakes in the implementation the results were incorrect.

The crucial problem here is that there is nothing in the code that checks assumptions or e.g. enforces certain properties of datasets/results. In @exr-implement-warnings and @sec-testing-and-validating we explore in more detail how you can implement some of these checks yourself.

:::{#exr-errors}
### Identify the error
For each of the following 10 exercises, identify the type of error, and fix the code so that it works as expected.

```{r}
#| eval: FALSE
# Exercise 1: Calculating average leaf Nitrogen content
mean(corre_continuous$leaf_N
     
# Exercise 2: Finding the most common growth form
mean(corre_categorical$growth_form)

# Exercise 3: Is there a relationship between plant family and leaf N content?
cor.test(corre_continuous$family, corre_continuous$leaf_N)

# Excercise 4: What is the average leaf dry mass?
mean(corre_continuous$leaf_dry_mass, na.rm = TRUE)

# Exercise 5: Select all the entries for the grass family
subset(corre_continuous, family = 'Poaceae')

# Exercise 6: Calculate mean leaf are
mean(corre_continuous$SLA)

# Exercise 7: Select the leaf area for the 1,000th plant
corre_continuous$leaf_area[10000]

# Exercise 8: Compute the average seed dry mass for grasses
subset(corre_continuous, family == 'Poaceae')$seed_dry_mass |> mean(na.rm = TRUE)

# Exercise 9: Compute the mean SLA for a specific family
mean_trait_by_family <- function(dataset, trait){
  mean(dataset[[trait]], na.rm = TRUE)
}
mean_trait_by_family(corre_continuous, 'SLA')

# Exercise 10: log-transform seed dry mass
log(corre_continuous$seed_dry_mass)
```
:::

:::{#exr-implement-warnings}
### Upgrading the implementation of the variance calculation
In @exr-variance you implemented the calculation of the variance. Here, you will make that function a bit safer to use. Add the following checks, decide yourself whether it should be a warning or an error:

- The variance of zero or one numbers is undefined
- The variance of a collection of all the same numbers (e.g. `c(4,4,4)`) is zero
:::

## Testing and validating {#sec-testing-and-validating}
In @sec-functions we discussed how and when to use functions. It turns out that by following our rule of thumb for when to create a function^[Is there a logical name for a sequence of steps? Then it should be a function. See @tip-function] we create functions that are often straightforward to test. 

As an example, we revisit @exr-mean-vs-median-all-traits: we want to compute the difference between the mean and the median many times, so it makes sense to implement this in a function.

```{r}
# Example function that we are going to test
mean_median_difference <- function(input){
  # We compute the absolute difference so it doesn't matter which number is bigger
  abs(mean(input, na.rm = TRUE) - median(input, na.rm = TRUE))
}

mean_median_difference(grassland_traits_environment$ld)
```



